<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scottish Fold Cat Jumper</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #87CEEB 70%, #228B22 100%);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            max-height: 100vh;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        .score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #333;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        .image-note {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 14px;
            text-align: center;
            max-width: 90%;
        }
    </style>
</head>
<body>
    <div class="instructions">
        SPACE / UP / TAP to jump! üêæ Avoid falling!
    </div>
    <div class="score">Score: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="image-note">
        üí° <strong>Custom Cat Image:</strong> Edit <code>catImg.src</code> in the JS below with your image URL/path (e.g., 'my-cat.png')!
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // üé® YOUR CUSTOM CAT IMAGE HERE! 
        // - Local file: 'images/my-scottish-fold.png' (put in same folder)
        // - Online URL: 'https://example.com/cat.png'
        // - PNG with transparent bg works best! Size ~100x80px ideal.
        const catImg = new Image();
        catImg.src = '';  // ‚Üê PASTE YOUR IMAGE PATH/URL HERE! Falls back to drawn cat if empty.

        let useCustomImage = false;
        catImg.onload = () => {
            useCustomImage = true;
            console.log('‚úÖ Custom cat image loaded!');
        };
        catImg.onerror = () => {
            console.log('‚ö†Ô∏è Using drawn cat (image failed to load)');
        };

        // Fallback drawn cat function (original cute vector)
        function drawFallbackCat(cat) {
            ctx.save();
            ctx.translate(cat.x - gameState.camera.x, cat.y);

            // Body (white fluffy)
            ctx.fillStyle = '#F5F5F5';
            ctx.shadowColor = '#FFF';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(30, 25, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.ellipse(30, 10, 20, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Folded ears
            ctx.fillStyle = '#E8E8E8';
            ctx.beginPath();
            ctx.moveTo(15, 5);
            ctx.lineTo(20, 12);
            ctx.lineTo(25, 5);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(45, 5);
            ctx.lineTo(40, 12);
            ctx.lineTo(35, 5);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(22, 8, 3, 0, Math.PI * 2);
            ctx.arc(38, 8, 3, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(30, 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#F5F5F5';
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(55, 25);
            ctx.quadraticCurveTo(70, 20, 75, 35);
            ctx.stroke();

            // Legs
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(15, 35, 8, 12);
            ctx.fillRect(37, 35, 8, 12);
            ctx.fillRect(45, 35, 8, 12);

            ctx.restore();
        }

        // Audio setup (unchanged)
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playChirp(startFreq, endFreq, duration, type = 'sine', vol = 0.2) {
            if (!audioCtx || audioCtx.state !== 'running') return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
            osc.type = type;
            gain.gain.setValueAtTime(vol, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
            osc.start(now);
            osc.stop(now + duration);
        }

        function playJumpSound() { playChirp(600, 1200, 0.15, 'sine', 0.25); }
        function playLandSound() { playChirp(300, 150, 0.2, 'sawtooth', 0.2); }
        function playFallSound() { playChirp(700, 150, 0.6, 'sine', 0.3); }

        // Game state (unchanged)
        let gameState = {
            cat: {
                x: 100,
                y: 400,
                width: 60,
                height: 50,
                vx: 0,
                vy: 0,
                onGround: false,
                jumpPower: -20,
                gravity: 0.7,
                speed: 2.5
            },
            rooftops: [],
            camera: { x: 0 },
            score: 0,
            gameOver: false,
            keys: {}
        };

        let prevOnGround = false;

        // Generate rooftops (unchanged)
        function generateRooftops() {
            gameState.rooftops = [];
            for (let i = 0; i < 20; i++) {
                gameState.rooftops.push({
                    x: i * 160 + 200,
                    y: 480 - Math.random() * 80,
                    width: 140 + Math.random() * 80,
                    height: 30
                });
            }
        }

        // Input (unchanged)
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
            initAudio();
        });
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            if (gameState.gameOver) {
                resetGame();
                return;
            }
            if (gameState.cat.onGround) {
                gameState.cat.vy = gameState.cat.jumpPower;
                gameState.cat.onGround = false;
                playJumpSound();
            }
        }, { passive: false });

        // UPDATED: Draw cat (image or fallback)
        function drawCat(cat) {
            const catX = cat.x - gameState.camera.x;
            const catY = cat.y;

            ctx.save();
            ctx.shadowColor = '#FFF';
            ctx.shadowBlur = 20;  // Glow effect for both!
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            if (useCustomImage && catImg.complete) {
                ctx.drawImage(catImg, catX, catY, cat.width, cat.height);
            } else {
                drawFallbackCat(cat);
            }

            ctx.restore();
        }

        // Draw rooftop (unchanged)
        function drawRooftop(rooftop) {
            const rx = rooftop.x - gameState.camera.x;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(rx, rooftop.y, rooftop.width, rooftop.height);
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(rx, rooftop.y - 5, rooftop.width, 5);
            ctx.fillStyle = '#654321';
            for (let i = 0; i < rooftop.width; i += 20) {
                ctx.fillRect(rx + i, rooftop.y, 10, 5);
            }
        }

        // Update (unchanged)
        function update() {
            if (gameState.gameOver) {
                if (gameState.keys['Space'] || gameState.keys['ArrowUp']) {
                    resetGame();
                }
                return;
            }

            prevOnGround = gameState.cat.onGround;

            if ((gameState.keys['Space'] || gameState.keys['ArrowUp']) && gameState.cat.onGround) {
                gameState.cat.vy = gameState.cat.jumpPower;
                gameState.cat.onGround = false;
                playJumpSound();
            }

            gameState.cat.vy += gameState.cat.gravity;
            gameState.cat.y += gameState.cat.vy;
            gameState.cat.x += gameState.cat.speed + gameState.cat.vx;
            gameState.cat.vx *= 0.8;

            gameState.camera.x = Math.max(0, gameState.cat.x - canvas.width / 2);

            gameState.cat.onGround = false;
            for (let rooftop of gameState.rooftops) {
                if (gameState.cat.x + gameState.cat.width > rooftop.x &&
                    gameState.cat.x < rooftop.x + rooftop.width &&
                    gameState.cat.y + gameState.cat.height > rooftop.y &&
                    gameState.cat.y + gameState.cat.height - gameState.cat.vy <= rooftop.y + 5 &&
                    gameState.cat.vy > 0) {
                    gameState.cat.y = rooftop.y - gameState.cat.height;
                    gameState.cat.vy = 0;
                    gameState.cat.onGround = true;
                    break;
                }
            }

            if (!prevOnGround && gameState.cat.onGround) {
                playLandSound();
            }

            if (gameState.rooftops[gameState.rooftops.length - 1].x < gameState.camera.x + canvas.width + 300) {
                gameState.rooftops.push({
                    x: gameState.rooftops[gameState.rooftops.length - 1].x + 130 + Math.random() * 50,
                    y: 480 - Math.random() * 80,
                    width: 140 + Math.random() * 80,
                    height: 30
                });
            }

            gameState.rooftops = gameState.rooftops.filter(r => r.x > gameState.camera.x - 200);

            if (gameState.cat.y > 700) {
                playFallSound();
                gameState.gameOver = true;
            }

            gameState.score = Math.floor(gameState.camera.x / 10);
            scoreElement.textContent = gameState.score;
        }

        // Render (unchanged except cat call)
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gameState.rooftops.forEach(drawRooftop);
            drawCat(gameState.cat);

            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFF';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('You Fell!', canvas.width / 2, canvas.height / 2 - 50);
                ctx.font = '24px Arial';
                ctx.fillText('SPACE / UP / TAP to Restart', canvas.width / 2, canvas.height / 2 + 20);
                ctx.textAlign = 'left';
            }
        }

        // Reset (unchanged)
        function resetGame() {
            generateRooftops();
            gameState.cat.x = 100;
            gameState.cat.y = gameState.rooftops[0].y - gameState.cat.height;
            gameState.cat.vy = 0;
            gameState.cat.vx = 0;
            gameState.cat.onGround = true;
            gameState.camera.x = 0;
            gameState.score = 0;
            gameState.gameOver = false;
            prevOnGround = true;
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start
        generateRooftops();
        resetGame();
        gameLoop();
    </script>
</body>
</html>
